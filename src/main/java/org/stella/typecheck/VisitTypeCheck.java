// File generated by the BNF Converter (bnfc 2.9.4.1).

package org.stella.typecheck;

import org.syntax.stella.Absyn.*;
import org.syntax.stella.Absyn.List;
import org.syntax.stella.Absyn.Record;
import org.syntax.stella.PrettyPrinter;

import java.util.*;

/*** Visitor Design Pattern for TypeCheck. ***/

/* This implements the common visitor design pattern.
   Tests show it to be slightly less efficient than the
   instanceof method, but easier to use.
   Replace the org.syntax.stella.Absyn.Type and ContextAndReturnType parameters with the desired return
   and context types.*/

public class VisitTypeCheck {
    public final class ContextAndExpectedType {
        HashMap<String, org.syntax.stella.Absyn.Type> context;
        org.syntax.stella.Absyn.Type expectedType;

        public ContextAndExpectedType(HashMap<String, Type> context, Type expectedType) {
            this.context = context;
            this.expectedType = expectedType;
        }
    }

    public class TypeError extends RuntimeException {
        public TypeError(String message) {
            super(message);
        }
    }

    public void recordTypeLegal(TypeRecord expected, TypeRecord actual) {
        LinkedList<String> names = new LinkedList<>();
        var expectedList = expected.listrecordfieldtype_;
        var currentList = actual.listrecordfieldtype_;
        if (expectedList.size() > currentList.size()) {
            throw new TypeError("size of the record does not correspond to the actual type");
        }

        for (RecordFieldType rft : currentList) {
            names.add(((ARecordFieldType) rft).stellaident_);
        }

        for (RecordFieldType rft : expectedList) {
            if (!names.contains(((ARecordFieldType) rft).stellaident_)) {
                throw new TypeError("a record does not contain the variable " + ((ARecordFieldType) rft).stellaident_);
            }
        }
    }

    public Type compareTypes(Expr e, Type actualType, Type expectedType) {
        if (expectedType == null) {
            return actualType;
        } else if (actualType.equals(expectedType)) {
            return expectedType;
        } else if (expectedType instanceof TypeFun et && actualType instanceof TypeFun at) {
            compareTypes(e, et.type_, at.type_);
            compareTypes(e, et.listtype_.get(0), at.listtype_.get(0));
            return expectedType;
        } else if (expectedType instanceof TypeRecord et && actualType instanceof TypeRecord at) {
            recordTypeLegal(et, at);
            return actualType; // questionable
        }

        throw new TypeError("expected " + PrettyPrinter.print(expectedType) + " but got " + PrettyPrinter.print(actualType) + " for expression " + PrettyPrinter.print(e));
    }

    public Type getVarType(org.syntax.stella.Absyn.Var p, ContextAndExpectedType arg) {
        /* Code for Var goes here */
        //p.stellaident_;
        Type varType = arg.context.get(p.stellaident_);
        if (varType == null) {
            throw new TypeError("undefined variable");
        } else {
            return varType;
        }
    }

    public class ProgramVisitor implements org.syntax.stella.Absyn.Program.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public org.syntax.stella.Absyn.Type visit(org.syntax.stella.Absyn.AProgram p, ContextAndExpectedType arg) {
            /* Code for AProgram goes here */
            p.languagedecl_.accept(new LanguageDeclVisitor(), arg);
            for (org.syntax.stella.Absyn.Extension x : p.listextension_) {
                x.accept(new ExtensionVisitor(), arg);
            }
            for (org.syntax.stella.Absyn.Decl x : p.listdecl_) {
                x.accept(new DeclVisitor(), arg);
            }
            return null;
        }
    }

    public class LanguageDeclVisitor implements org.syntax.stella.Absyn.LanguageDecl.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public org.syntax.stella.Absyn.Type visit(org.syntax.stella.Absyn.LanguageCore p, ContextAndExpectedType arg) {
            /* Code for LanguageCore goes here */
            return null;
        }
    }

    public class ExtensionVisitor implements org.syntax.stella.Absyn.Extension.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public org.syntax.stella.Absyn.Type visit(org.syntax.stella.Absyn.AnExtension p, ContextAndExpectedType arg) {
            /* Code for AnExtension goes here */
            for (String x : p.listextensionname_) {
                //x;
            }
            return null;
        }
    }

    public class DeclVisitor implements org.syntax.stella.Absyn.Decl.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public org.syntax.stella.Absyn.Type visit(org.syntax.stella.Absyn.DeclFun p, ContextAndExpectedType arg) {
            /* Code for DeclFun goes here */
            System.out.println("Visiting declaration of function " + p.stellaident_);

            for (org.syntax.stella.Absyn.Annotation x : p.listannotation_) {
                x.accept(new AnnotationVisitor(), arg);
            }
            //p.stellaident_;
            for (org.syntax.stella.Absyn.ParamDecl x : p.listparamdecl_) {
                x.accept(new ParamDeclVisitor(), arg);
            }
            p.returntype_.accept(new ReturnTypeVisitor(), arg);
            p.throwtype_.accept(new ThrowTypeVisitor(), arg);
            for (org.syntax.stella.Absyn.Decl x : p.listdecl_) {
                x.accept(new DeclVisitor(), arg);
            }

            HashMap newContext = new HashMap<>(arg.context);
            AParamDecl paramDecl = (AParamDecl) p.listparamdecl_.get(0);
            newContext.put(paramDecl.stellaident_, paramDecl.type_);

            Type returnType = p.returntype_.accept(new ReturnType.Visitor<Type, Object>() {
                @Override
                public Type visit(NoReturnType p, Object arg) {
                    throw new TypeError("missing return type in declaration");
                }

                public Type visit(DeclExceptionType  p, Object arg) {
                    return null;
                }

                public Type visit(DeclExceptionVariant  p, Object arg) {
                    return null;
                }

                @Override
                public Type visit(SomeReturnType p, Object arg) {
                    return p.type_;
                }
            }, null);

            p.expr_.accept(new ExprVisitor(), new ContextAndExpectedType(newContext, returnType));

            ListType argListType = new ListType();
            argListType.add(paramDecl.type_);
            arg.context.put(p.stellaident_, new TypeFun(argListType, returnType));
            return null;
        }

        @Override
        public Type visit(DeclFunGeneric p, ContextAndExpectedType arg) {
            ListStellaIdent genTypes = p.liststellaident_;

            for (org.syntax.stella.Absyn.Annotation x : p.listannotation_) {
                x.accept(new AnnotationVisitor(), arg);
            }

            for (org.syntax.stella.Absyn.ParamDecl x : p.listparamdecl_) {
                if (((AParamDecl) x).type_ instanceof TypeVar tv && !(genTypes.contains(tv.stellaident_))) {
                    throw new TypeError("unknown TypeVar: " + genTypes.contains(tv.stellaident_));
                }
                x.accept(new ParamDeclVisitor(), arg);
            }

            if (p.returntype_ instanceof SomeReturnType srt && srt.type_ instanceof TypeVar tv) {
                if (!(genTypes.contains(tv.stellaident_))) {
                    throw new TypeError("unknown TypeVar: " + genTypes.contains(tv.stellaident_));
                }
            }
            p.returntype_.accept(new ReturnTypeVisitor(), arg);
            p.throwtype_.accept(new ThrowTypeVisitor(), arg);
            for (org.syntax.stella.Absyn.Decl x : p.listdecl_) {
                x.accept(new DeclVisitor(), arg);
            }

            HashMap newContext = new HashMap<>(arg.context);
            AParamDecl paramDecl = (AParamDecl) p.listparamdecl_.get(0);
            newContext.put(paramDecl.stellaident_, paramDecl.type_);

            Type returnType = p.returntype_.accept(new ReturnType.Visitor<Type, Object>() {
                @Override
                public Type visit(NoReturnType p, Object arg) {
                    throw new TypeError("missing return type in declaration");
                }

                public Type visit(DeclExceptionType  p, Object arg) {
                    return null;
                }

                public Type visit(DeclExceptionVariant  p, Object arg) {
                    return null;
                }

                @Override
                public Type visit(SomeReturnType p, Object arg) {
                    return p.type_;
                }
            }, null);

            p.expr_.accept(new ExprVisitor(), new ContextAndExpectedType(newContext, returnType));
            if (returnType instanceof TypeForAll tfa) {
                TypeFun typeFun = (TypeFun) tfa.type_;
                returnType = new TypeGenericFun(typeFun.listtype_, typeFun.type_, tfa.liststellaident_);
            }

            ListType argListType = new ListType();
            argListType.add(paramDecl.type_);
            arg.context.put(p.stellaident_, new TypeGenericFun(argListType, returnType, genTypes));
            return null;
        }

        public org.syntax.stella.Absyn.Type visit(org.syntax.stella.Absyn.DeclTypeAlias p, ContextAndExpectedType arg) {
            /* Code for DeclTypeAlias goes here */
            //p.stellaident_;
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        @Override
        public Type visit(DeclExceptionType p, ContextAndExpectedType arg) {
            return null;
        }

        @Override
        public Type visit(DeclExceptionVariant p, ContextAndExpectedType arg) {
            return null;
        }
    }

    public class LocalDeclVisitor implements org.syntax.stella.Absyn.LocalDecl.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public Type visit(org.syntax.stella.Absyn.ALocalDecl p, ContextAndExpectedType arg) {
            /* Code for ALocalDecl goes here */
            p.decl_.accept(new DeclVisitor(), arg);
            return null;
        }
    }

    public class AnnotationVisitor implements org.syntax.stella.Absyn.Annotation.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public Type visit(org.syntax.stella.Absyn.InlineAnnotation p, ContextAndExpectedType arg) {
            /* Code for InlineAnnotation goes here */
            return null;
        }
    }

    public class ParamDeclVisitor implements org.syntax.stella.Absyn.ParamDecl.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public Type visit(org.syntax.stella.Absyn.AParamDecl p, ContextAndExpectedType arg) {
            /* Code for AParamDecl goes here */
            //p.stellaident_;
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }
    }

    public class ReturnTypeVisitor implements org.syntax.stella.Absyn.ReturnType.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public Type visit(org.syntax.stella.Absyn.NoReturnType p, ContextAndExpectedType arg) {
            /* Code for NoReturnType goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.SomeReturnType p, ContextAndExpectedType arg) {
            /* Code for SomeReturnType goes here */
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }
    }

    public class ThrowTypeVisitor implements org.syntax.stella.Absyn.ThrowType.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public Type visit(org.syntax.stella.Absyn.NoThrowType p, ContextAndExpectedType arg) {
            /* Code for NoThrowType goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.SomeThrowType p, ContextAndExpectedType arg) {
            /* Code for SomeThrowType goes here */
            for (org.syntax.stella.Absyn.Type x : p.listtype_) {
                x.accept(new TypeVisitor(), arg);
            }
            return null;
        }
    }

    public class TypeVisitor implements org.syntax.stella.Absyn.Type.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public Type visit(org.syntax.stella.Absyn.TypeFun p, ContextAndExpectedType arg) {
            /* Code for TypeFun goes here */
            for (org.syntax.stella.Absyn.Type x : p.listtype_) {
                x.accept(new TypeVisitor(), arg);
            }
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        @Override
        public Type visit(TypeForAll p, ContextAndExpectedType arg) {
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeRec p, ContextAndExpectedType arg) {
            /* Code for TypeRec goes here */
            //p.stellaident_;
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeSum p, ContextAndExpectedType arg) {
            /* Code for TypeSum goes here */
            p.type_1.accept(new TypeVisitor(), arg);
            p.type_2.accept(new TypeVisitor(), arg);
            return null;
        }

        public Type visit(TypeTop p, ContextAndExpectedType arg) {
            return null;
        }

        public Type visit(TypeBottom p, ContextAndExpectedType arg) {
            return null;
        }

        public Type visit(TypeRef p, ContextAndExpectedType arg) {
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeTuple p, ContextAndExpectedType arg) {
            /* Code for TypeTuple goes here */
            for (org.syntax.stella.Absyn.Type x : p.listtype_) {
                x.accept(new TypeVisitor(), arg);
            }
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeRecord p, ContextAndExpectedType arg) {
            /* Code for TypeRecord goes here */
            for (org.syntax.stella.Absyn.RecordFieldType x : p.listrecordfieldtype_) {
                x.accept(new RecordFieldTypeVisitor(), arg);
            }
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeVariant p, ContextAndExpectedType arg) {
            /* Code for TypeVariant goes here */
            for (org.syntax.stella.Absyn.VariantFieldType x : p.listvariantfieldtype_) {
                x.accept(new VariantFieldTypeVisitor(), arg);
            }
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeList p, ContextAndExpectedType arg) {
            /* Code for TypeList goes here */
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeBool p, ContextAndExpectedType arg) {
            /* Code for TypeBool goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeNat p, ContextAndExpectedType arg) {
            /* Code for TypeNat goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeUnit p, ContextAndExpectedType arg) {
            /* Code for TypeUnit goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeVar p, ContextAndExpectedType arg) {
            /* Code for TypeVar goes here */
            //p.stellaident_;
            return null;
        }
    }

    public class MatchCaseVisitor implements org.syntax.stella.Absyn.MatchCase.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public Type visit(org.syntax.stella.Absyn.AMatchCase p, ContextAndExpectedType arg) {
            /* Code for AMatchCase goes here */
            p.pattern_.accept(new PatternVisitor(), arg);
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }
    }

    public class OptionalTypingVisitor implements org.syntax.stella.Absyn.OptionalTyping.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public Type visit(org.syntax.stella.Absyn.NoTyping p, ContextAndExpectedType arg) {
            /* Code for NoTyping goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.SomeTyping p, ContextAndExpectedType arg) {
            /* Code for SomeTyping goes here */
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }
    }

    public class PatternDataVisitor implements org.syntax.stella.Absyn.PatternData.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public Type visit(org.syntax.stella.Absyn.NoPatternData p, ContextAndExpectedType arg) {
            /* Code for NoPatternData goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.SomePatternData p, ContextAndExpectedType arg) {
            /* Code for SomePatternData goes here */
            p.pattern_.accept(new PatternVisitor(), arg);
            return null;
        }
    }

    public class ExprDataVisitor implements org.syntax.stella.Absyn.ExprData.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public Type visit(org.syntax.stella.Absyn.NoExprData p, ContextAndExpectedType arg) {
            /* Code for NoExprData goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.SomeExprData p, ContextAndExpectedType arg) {
            /* Code for SomeExprData goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }
    }

    public class PatternVisitor implements org.syntax.stella.Absyn.Pattern.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public Type visit(org.syntax.stella.Absyn.PatternVariant p, ContextAndExpectedType arg) {
            /* Code for PatternVariant goes here */
            //p.stellaident_;
            p.patterndata_.accept(new PatternDataVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternInl p, ContextAndExpectedType arg) {
            /* Code for PatternInl goes here */
            p.pattern_.accept(new PatternVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternInr p, ContextAndExpectedType arg) {
            /* Code for PatternInr goes here */
            p.pattern_.accept(new PatternVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternTuple p, ContextAndExpectedType arg) {
            /* Code for PatternTuple goes here */
            for (org.syntax.stella.Absyn.Pattern x : p.listpattern_) {
                x.accept(new PatternVisitor(), arg);
            }
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternRecord p, ContextAndExpectedType arg) {
            /* Code for PatternRecord goes here */
            for (org.syntax.stella.Absyn.LabelledPattern x : p.listlabelledpattern_) {
                x.accept(new LabelledPatternVisitor(), arg);
            }
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternList p, ContextAndExpectedType arg) {
            /* Code for PatternList goes here */
            for (org.syntax.stella.Absyn.Pattern x : p.listpattern_) {
                x.accept(new PatternVisitor(), arg);
            }
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternCons p, ContextAndExpectedType arg) {
            /* Code for PatternCons goes here */
            p.pattern_1.accept(new PatternVisitor(), arg);
            p.pattern_2.accept(new PatternVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternFalse p, ContextAndExpectedType arg) {
            /* Code for PatternFalse goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternTrue p, ContextAndExpectedType arg) { /* Code for PatternTrue goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternUnit p, ContextAndExpectedType arg) { /* Code for PatternUnit goes here */
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternInt p, ContextAndExpectedType arg) {
            /* Code for PatternInt goes here */
            //p.integer_;
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternSucc p, ContextAndExpectedType arg) {
            /* Code for PatternSucc goes here */
            p.pattern_.accept(new PatternVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.PatternVar p, ContextAndExpectedType arg) {
            /* Code for PatternVar goes here */
            //p.stellaident_;
            return null;
        }
    }

    public class LabelledPatternVisitor implements org.syntax.stella.Absyn.LabelledPattern.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public Type visit(org.syntax.stella.Absyn.ALabelledPattern p, ContextAndExpectedType arg) {
            /* Code for ALabelledPattern goes here */
            //p.stellaident_;
            p.pattern_.accept(new PatternVisitor(), arg);
            return null;
        }
    }

    public class BindingVisitor implements org.syntax.stella.Absyn.Binding.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public Type visit(org.syntax.stella.Absyn.ABinding p, ContextAndExpectedType arg) {
            /* Code for ABinding goes here */
            //p.stellaident_;
            String name = p.stellaident_;
            // find that this name exists
            var expectedList = ((TypeRecord) arg.expectedType).listrecordfieldtype_;
            LinkedList<String> expectedNames = new LinkedList<>();
            for (RecordFieldType rft : expectedList) {
                expectedNames.add(((ARecordFieldType) rft).stellaident_);
            }

            if (expectedNames.contains(name)) {
                Type expectedType = null;
                for (RecordFieldType rft : expectedList) {
                    if (((ARecordFieldType) rft).stellaident_.equals(name)) {
                        expectedType = ((ARecordFieldType) rft).type_;
                        break;
                    }
                }
                p.expr_.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, expectedType));
            }

            return null;
        }
    }

    public class ExprVisitor implements org.syntax.stella.Absyn.Expr.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public Type visit(org.syntax.stella.Absyn.Sequence p, ContextAndExpectedType arg) {
            /* Code for Sequence goes here */
            p.expr_1.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, new TypeUnit()));
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(Assign p, ContextAndExpectedType arg) {
            if (arg.expectedType instanceof TypeUnit) {
                Type t1 = p.expr_1.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, null));
                if (!(t1 instanceof TypeRef)) {
                    throw new TypeError("expected TypeRef, got " + t1.getClass());
                }
                Type t = ((TypeRef) t1).type_;
                Type t2 = p.expr_2.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, null));
                return compareTypes(p.expr_2, t2, t);
            }
            throw new TypeError("expected " + arg.expectedType + ", got Assign");
        }

        public Type visit(org.syntax.stella.Absyn.If p, ContextAndExpectedType arg) {
            /* Code for If goes here */
            System.out.println("Visiting if");
            p.expr_1.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, new TypeBool()));
            Type thenType = p.expr_2.accept(new ExprVisitor(), arg);
            Type elseType = p.expr_3.accept(new ExprVisitor(), arg);
            if (thenType instanceof PanicType && elseType instanceof PanicType) {
                return arg.expectedType;
            } else if (thenType instanceof PanicType) {
                return compareTypes(p, elseType, arg.expectedType);
            } else if (elseType instanceof PanicType) {
                return compareTypes(p, thenType, arg.expectedType);
            }
            compareTypes(p, elseType, arg.expectedType);
            compareTypes(p, elseType, thenType);
            return compareTypes(p, thenType, arg.expectedType);
        }

        public Type visit(org.syntax.stella.Absyn.Let p, ContextAndExpectedType arg) {
            /* Code for Let goes here */
            for (org.syntax.stella.Absyn.PatternBinding x : p.listpatternbinding_) {
                x.accept(new PatternBindingVisitor(), arg);
            }
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.LetRec p, ContextAndExpectedType arg) {
            /* Code for LetRec goes here */
            for (org.syntax.stella.Absyn.PatternBinding x : p.listpatternbinding_) {
                x.accept(new PatternBindingVisitor(), arg);
            }
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        @Override
        public Type visit(TypeAbstraction p, ContextAndExpectedType arg) {
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.LessThan p, ContextAndExpectedType arg) {
            /* Code for LessThan goes here */
            Type t1 = p.expr_1.accept(new ExprVisitor(), arg);
            Type t2 = p.expr_2.accept(new ExprVisitor(), arg);
            return compareTypes(p.expr_1, t1, t2);
        }

        public Type visit(org.syntax.stella.Absyn.LessThanOrEqual p, ContextAndExpectedType arg) {
            /* Code for LessThanOrEqual goes here */
            Type t1 = p.expr_1.accept(new ExprVisitor(), arg);
            Type t2 = p.expr_2.accept(new ExprVisitor(), arg);
            return compareTypes(p.expr_1, t1, t2);
        }

        public Type visit(org.syntax.stella.Absyn.GreaterThan p, ContextAndExpectedType arg) {
            /* Code for GreaterThan goes here */
            Type t1 = p.expr_1.accept(new ExprVisitor(), arg);
            Type t2 = p.expr_2.accept(new ExprVisitor(), arg);
            return compareTypes(p.expr_1, t1, t2);
        }

        public Type visit(org.syntax.stella.Absyn.GreaterThanOrEqual p, ContextAndExpectedType arg) {
            /* Code for GreaterThanOrEqual goes here */
            Type t1 = p.expr_1.accept(new ExprVisitor(), arg);
            Type t2 = p.expr_2.accept(new ExprVisitor(), arg);
            return compareTypes(p.expr_1, t1, t2);
        }

        public Type visit(org.syntax.stella.Absyn.Equal p, ContextAndExpectedType arg) {
            /* Code for Equal goes here */
            Type t1 = p.expr_1.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, null));
            Type t2 = p.expr_2.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, null));
            return compareTypes(p.expr_1, t1, t2);
        }

        public Type visit(org.syntax.stella.Absyn.NotEqual p, ContextAndExpectedType arg) {
            /* Code for NotEqual goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.TypeAsc p, ContextAndExpectedType arg) {
            /* Code for TypeAsc goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        public Type visit(TypeCast p, ContextAndExpectedType arg) {
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Abstraction p, ContextAndExpectedType arg) {
            /* Code for Abstraction goes here */
            HashMap newContext = new HashMap<>(arg.context);
            AParamDecl paramDecl = (AParamDecl) p.listparamdecl_.get(0);
            newContext.put(paramDecl.stellaident_, paramDecl.type_);

            Type bodyType = null;
            if (arg.expectedType != null) {
                if (arg.expectedType instanceof TypeFun tf) {
                    compareTypes(new Var(paramDecl.stellaident_), paramDecl.type_, tf.listtype_.get(0));
                    bodyType = ((TypeFun) arg.expectedType).type_;
                } else if (arg.expectedType instanceof TypeForAll tfa) {
                    compareTypes(new Var(paramDecl.stellaident_), paramDecl.type_, ((TypeFun) tfa.type_).listtype_.get(0));
                    bodyType = ((TypeFun) tfa.type_).type_;
                } else {
                    throw new TypeError("unexpected lambda abstraction");
                }
            }
            Type expectedType = bodyType;
            bodyType = p.expr_.accept(new ExprVisitor(), new ContextAndExpectedType(newContext, expectedType));
            if (bodyType instanceof PanicType) {
                bodyType = expectedType;
            }

            ListType argType = new ListType();
            argType.add(paramDecl.type_);
            if (arg.expectedType instanceof TypeForAll tfa) {
                return compareTypes(p, new TypeFun(argType, bodyType), tfa.type_);
            } else {
                return compareTypes(p, new TypeFun(argType, bodyType), arg.expectedType);
            }
        }

        public Type visit(org.syntax.stella.Absyn.Variant p, ContextAndExpectedType arg) {
            /* Code for Variant goes here */
            //p.stellaident_;
            p.exprdata_.accept(new ExprDataVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Match p, ContextAndExpectedType arg) {
            /* Code for Match goes here */
            Type type = p.expr_.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, null));
            if (!(type instanceof TypeSum)) {
                throw new TypeError("expected TypeSum, got " + type.getClass());
            }

            AMatchCase amc1 = (AMatchCase) p.listmatchcase_.get(0);
            AMatchCase amc2 = (AMatchCase) p.listmatchcase_.get(1);
            PatternInl inl;
            PatternInr inr;
            if (amc1.pattern_ instanceof PatternInl && amc2.pattern_ instanceof PatternInr) {
                inr = (PatternInr) amc2.pattern_;
                inl = (PatternInl) amc1.pattern_;
            } else if (amc1.pattern_ instanceof PatternInr && amc2.pattern_ instanceof PatternInl) {
                inr = (PatternInr) amc1.pattern_;
                inl = (PatternInl) amc2.pattern_;
            } else {
                throw new TypeError("expected to have PatternInl and PatternInr within TypeSum");
            }

            HashMap inlContext = new HashMap<>(arg.context);
            if (inl.pattern_ instanceof PatternVar var) {
                inlContext.put(var.stellaident_, ((TypeSum) type).type_1);
            }

            HashMap inrContext = new HashMap<>(arg.context);
            if (inr.pattern_ instanceof PatternVar var) {
                inrContext.put(var.stellaident_, ((TypeSum) type).type_2);
            }

            if (amc1.pattern_ instanceof PatternInl) {
                amc1.accept(new MatchCaseVisitor(), new ContextAndExpectedType(inlContext, arg.expectedType));
                amc2.accept(new MatchCaseVisitor(), new ContextAndExpectedType(inrContext, arg.expectedType));
            } else {
                amc1.accept(new MatchCaseVisitor(), new ContextAndExpectedType(inrContext, arg.expectedType));
                amc2.accept(new MatchCaseVisitor(), new ContextAndExpectedType(inlContext, arg.expectedType));
            }

            return null;
        }

        public Type visit(org.syntax.stella.Absyn.List p, ContextAndExpectedType arg) {
            /* Code for List goes here */
            for (org.syntax.stella.Absyn.Expr x : p.listexpr_) {
                x.accept(new ExprVisitor(), arg);
            }
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Add p, ContextAndExpectedType arg) {
            /* Code for Add goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Subtract p, ContextAndExpectedType arg) {
            /* Code for Subtract goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.LogicOr p, ContextAndExpectedType arg) {
            /* Code for LogicOr goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Multiply p, ContextAndExpectedType arg) {
            /* Code for Multiply goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Divide p, ContextAndExpectedType arg) {
            /* Code for Divide goes here */
            Type t1 = p.expr_1.accept(new ExprVisitor(), arg);
            Type t2 = p.expr_2.accept(new ExprVisitor(), arg);
            compareTypes(p, t1, new TypeNat());
            compareTypes(p, new TypeNat(), arg.expectedType);
            return compareTypes(p, t2, new TypeNat());
        }

        public Type visit(org.syntax.stella.Absyn.LogicAnd p, ContextAndExpectedType arg) {
            /* Code for LogicAnd goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(Ref p, ContextAndExpectedType arg) {
            if (arg.expectedType instanceof TypeRef tr) {
                p.expr_.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, tr.type_));
                return null;
            }
            throw new TypeError("expected " + arg.expectedType + ", got TypeRef");
        }

        public Type visit(Deref p, ContextAndExpectedType arg) {
            p.expr_.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, new TypeRef(arg.expectedType)));
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Application p, ContextAndExpectedType arg) {
            /* Code for Application goes here */
            if (p.expr_ instanceof Panic) {
                throw new TypeError("application to panic");
            }
            Type funType = p.expr_.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, null));
            if (funType instanceof TypeGenericFun tgf) {
                Expr typeApplication = p.expr_;
                try {
                    while (!(typeApplication instanceof TypeApplication)) {
                        typeApplication = ((Application) typeApplication).expr_;
                    }
                } catch (Exception e) {
                    throw new TypeError("no type for generic function was indicated");
                }

                Map<String, Type> types = new HashMap<>();
                for (int i = 0; i < tgf.generics_.size(); i++) {
                    types.put(tgf.generics_.get(i), ((TypeApplication) typeApplication).listtype_.get(i));
                }

                Type argType;
                if (((TypeFun) funType).listtype_.get(0) instanceof TypeVar tv) {
                    argType = types.get(tv.stellaident_);
                } else {
                    argType = ((TypeFun) funType).listtype_.get(0);
                }
                Type retType;
                if (((TypeFun) funType).type_ instanceof TypeVar tv) {
                    retType = types.get(tv.stellaident_);
                } else {
                    retType = ((TypeFun) funType).type_;
                    if (retType instanceof TypeFun tf && !(retType instanceof TypeGenericFun)) {
                        retType = new TypeGenericFun(tf.listtype_, tf.type_, tgf.generics_);
                    } else if (retType instanceof TypeForAll tfa) {
                        TypeFun tf = (TypeFun) tfa.type_;
                        retType = new TypeGenericFun(tf.listtype_, tf.type_, tgf.generics_);
                    }

                    if (retType instanceof TypeGenericFun retTypeTGF && retTypeTGF.type_ instanceof TypeVar typeVar) {
                        retType = new TypeGenericFun(retTypeTGF.listtype_, types.get(typeVar.stellaident_), retTypeTGF.generics_);
                    }

                    Type t = p.listexpr_.get(0).accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, argType));
                    if (t instanceof PanicType) {
                        throw new TypeError("trying to apply panic as an argument");
                    }

                    if (tgf.type_ instanceof TypeFun tf && !(retType instanceof TypeGenericFun)) {
                        return new TypeGenericFun(tf.listtype_, tf.type_, tgf.generics_);
                    }
                    return compareTypes(p, retType, arg.expectedType);
                }
                Type t = p.listexpr_.get(0).accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, argType));
                if (t instanceof PanicType) {
                    throw new TypeError("trying to apply panic as an argument");
                }
                return compareTypes(p, retType, arg.expectedType);
            } else if (funType instanceof TypeFun typeFun) {
                Type argType = typeFun.listtype_.get(0);
                Type retType = typeFun.type_;
                Type t = p.listexpr_.get(0).accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, argType));
                if (t instanceof PanicType) {
                    throw new TypeError("trying to apply panic as an argument");
                }
                return compareTypes(p, retType, arg.expectedType);
            } else if (funType == null) {
                return arg.expectedType; // panic!
            } else {
                throw new TypeError("trying to apply an expression of a non-function type");
            }
        }

        @Override
        public Type visit(TypeApplication p, ContextAndExpectedType arg) {
            Type funType = p.expr_.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, null));
            if (funType instanceof TypeForAll tfa) {
                funType = new TypeGenericFun(((TypeFun) tfa.type_).listtype_, ((TypeFun) tfa.type_).type_, tfa.liststellaident_);
            }
            return funType;
        }

        public Type visit(org.syntax.stella.Absyn.DotRecord p, ContextAndExpectedType arg) {
            /* Code for DotRecord goes here */
            String dotName = p.stellaident_;
            Type actualType = null;
            if (p.expr_ instanceof Var v) {
                Type recordType = getVarType(v, arg);
                if (!(recordType instanceof TypeRecord)) {
                    throw new TypeError("variable '" + v.stellaident_ + "' should be record");
                }
                for (RecordFieldType rft : ((TypeRecord) recordType).listrecordfieldtype_) {
                    if (((ARecordFieldType) rft).stellaident_.equals(dotName)) {
                        actualType = ((ARecordFieldType) rft).type_;
                        break;
                    }
                }

                if (actualType == null) {
                    throw new TypeError("variable '" + dotName + "' does not match the pattern of the record");
                }
            }

            p.expr_.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, null));
            //p.stellaident_;
            return compareTypes(p.expr_, actualType, arg.expectedType);
        }

        public Type visit(org.syntax.stella.Absyn.DotTuple p, ContextAndExpectedType arg) {
            /* Code for DotTuple goes here */
            Type t = p.expr_.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, null));
            if (t instanceof TypeTuple typeTuple) {
                compareTypes(p.expr_, typeTuple.listtype_.get(p.integer_ - 1), arg.expectedType);
            } else {
                throw new TypeError("expected Tuple, got " + t.getClass());
            }
            //p.integer_;
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Tuple p, ContextAndExpectedType arg) {
            /* Code for Tuple goes here */
            if (!(arg.expectedType instanceof TypeTuple)) {
                throw new TypeError("expected Tuple, got " + arg.expectedType.getClass());
            } else if (p.listexpr_.size() != ((TypeTuple) arg.expectedType).listtype_.size()) {
                throw new TypeError("size of the tuple does not correspond to the actual type");
            }
            int i = 0;
            for (org.syntax.stella.Absyn.Expr x : p.listexpr_) {
                Type t = ((TypeTuple) arg.expectedType).listtype_.get(i);
                i++;
                x.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, t));
            }
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Record p, ContextAndExpectedType arg) {
            /* Code for Record goes here */
            LinkedList<String> names = new LinkedList<>();
            var expectedList = ((TypeRecord) arg.expectedType).listrecordfieldtype_;
            var currentList = p.listbinding_;
            if (expectedList.size() > currentList.size()) {
                throw new TypeError("size of the record does not correspond to the actual type");
            }

            for (int i = 0; i < currentList.size(); i++) {
                names.add(((ABinding) currentList.get(i)).stellaident_);
            }

            for (RecordFieldType rft : expectedList) {
                if (!names.contains(((ARecordFieldType) rft).stellaident_)) {
                    throw new TypeError("a record does not contain the variable " + ((ARecordFieldType) rft).stellaident_);
                }
            }

            for (org.syntax.stella.Absyn.Binding x : p.listbinding_) {
                x.accept(new BindingVisitor(), arg);
            }
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.ConsList p, ContextAndExpectedType arg) {
            /* Code for ConsList goes here */
            p.expr_1.accept(new ExprVisitor(), arg);
            p.expr_2.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Head p, ContextAndExpectedType arg) {
            /* Code for Head goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.IsEmpty p, ContextAndExpectedType arg) {
            /* Code for IsEmpty goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Tail p, ContextAndExpectedType arg) {
            /* Code for Tail goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(Panic p, ContextAndExpectedType arg) {
            return new PanicType();
        }

        public Type visit(Throw p, ContextAndExpectedType arg) {
            return null;
        }

        public Type visit(TryCatch p, ContextAndExpectedType arg) {
            return null;
        }

        public Type visit(TryWith p, ContextAndExpectedType arg) {
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Inl p, ContextAndExpectedType arg) {
            /* Code for Inl goes here */
            if (!(arg.expectedType instanceof TypeSum)) {
                throw new TypeError("expected " + PrettyPrinter.print(arg.expectedType) + " but got TypeSum for expression " + PrettyPrinter.print(p));
            }
            try {
                p.expr_.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, ((TypeSum)arg.expectedType).type_1));
            } catch (Exception e) {
                p.expr_.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, ((TypeSum)arg.expectedType).type_2));
            }
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Inr p, ContextAndExpectedType arg) {
            /* Code for Inr goes here */
            if (!(arg.expectedType instanceof TypeSum)) {
                throw new TypeError("expected " + PrettyPrinter.print(arg.expectedType) + " but got TypeSum for expression " + PrettyPrinter.print(p));
            }
            try {
                p.expr_.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, ((TypeSum)arg.expectedType).type_1));
            } catch (Exception e) {
                p.expr_.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, ((TypeSum)arg.expectedType).type_2));
            }
//            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Succ p, ContextAndExpectedType arg) {
            /* Code for Succ goes here */
            System.out.println("Visiting succ");
            p.expr_.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, new TypeNat()));
            return compareTypes(p, new TypeNat(), arg.expectedType);
        }

        public Type visit(org.syntax.stella.Absyn.LogicNot p, ContextAndExpectedType arg) {
            /* Code for LogicNot goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Pred p, ContextAndExpectedType arg) {
            /* Code for Pred goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.IsZero p, ContextAndExpectedType arg) {
            /* Code for IsZero goes here */
            p.expr_.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, new TypeNat()));
            return compareTypes(p, new TypeBool(), arg.expectedType);
        }

        public Type visit(org.syntax.stella.Absyn.Fix p, ContextAndExpectedType arg) {
            /* Code for Fix goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.NatRec p, ContextAndExpectedType arg) {
            /* Code for NatRec goes here */
            p.expr_1.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, new TypeNat()));
            Type returnType = p.expr_2.accept(new ExprVisitor(), arg);
            ListType arg1 = new ListType();
            arg1.add(new TypeNat());
            ListType arg2 = new ListType();
            arg2.add(returnType);
            Type stepType = new TypeFun(arg1, new TypeFun(arg2, returnType));
            p.expr_3.accept(new ExprVisitor(), new ContextAndExpectedType(arg.context, stepType));
            return compareTypes(p, returnType, arg.expectedType);
        }

        public Type visit(org.syntax.stella.Absyn.Fold p, ContextAndExpectedType arg) {
            /* Code for Fold goes here */
            p.type_.accept(new TypeVisitor(), arg);
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Unfold p, ContextAndExpectedType arg) {
            /* Code for Unfold goes here */
            p.type_.accept(new TypeVisitor(), arg);
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.ConstTrue p, ContextAndExpectedType arg) {
            /* Code for ConstTrue goes here */
            return compareTypes(p, new TypeBool(), arg.expectedType);
        }

        public Type visit(org.syntax.stella.Absyn.ConstFalse p, ContextAndExpectedType arg) {
            /* Code for ConstFalse goes here */
            return compareTypes(p, new TypeBool(), arg.expectedType);
        }

        public Type visit(org.syntax.stella.Absyn.ConstUnit p, ContextAndExpectedType arg) {
            /* Code for ConstUnit goes here */
            return compareTypes(p, new TypeUnit(), arg.expectedType);
        }

        public Type visit(org.syntax.stella.Absyn.ConstInt p, ContextAndExpectedType arg) {
            /* Code for ConstInt goes here */
            //p.integer_;
            return compareTypes(p, new TypeNat(), arg.expectedType);
        }

        public Type visit(ConstMemory p, ContextAndExpectedType arg) {
            return null;
        }

        public Type visit(org.syntax.stella.Absyn.Var p, ContextAndExpectedType arg) {
            /* Code for Var goes here */
            //p.stellaident_;
            Type varType = arg.context.get(p.stellaident_);
            if (varType == null) {
                throw new TypeError("undefined variable");
            } else {
                return compareTypes(p, varType, arg.expectedType);
            }
        }
    }

    public class PatternBindingVisitor implements org.syntax.stella.Absyn.PatternBinding.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public Type visit(org.syntax.stella.Absyn.APatternBinding p, ContextAndExpectedType arg) {
            /* Code for APatternBinding goes here */
            p.pattern_.accept(new PatternVisitor(), arg);
            p.expr_.accept(new ExprVisitor(), arg);
            return null;
        }
    }

    public class VariantFieldTypeVisitor implements org.syntax.stella.Absyn.VariantFieldType.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public Type visit(org.syntax.stella.Absyn.AVariantFieldType p, ContextAndExpectedType arg) {
            /* Code for AVariantFieldType goes here */
            //p.stellaident_;
            p.optionaltyping_.accept(new OptionalTypingVisitor(), arg);
            return null;
        }
    }

    public class RecordFieldTypeVisitor implements org.syntax.stella.Absyn.RecordFieldType.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public Type visit(org.syntax.stella.Absyn.ARecordFieldType p, ContextAndExpectedType arg) {
            /* Code for ARecordFieldType goes here */
            //p.stellaident_;
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }
    }

    public class TypingVisitor implements org.syntax.stella.Absyn.Typing.Visitor<org.syntax.stella.Absyn.Type, ContextAndExpectedType> {
        public Type visit(org.syntax.stella.Absyn.ATyping p, ContextAndExpectedType arg) {
            /* Code for ATyping goes here */
            p.expr_.accept(new ExprVisitor(), arg);
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }
    }
}
